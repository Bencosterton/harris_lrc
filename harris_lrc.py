import logging, subprocess, re, socket, time, json, threading, base64, argparse
from datetime import datetime
from http.server import HTTPServer, BaseHTTPRequestHandler
from urllib.parse import urlparse, parse_qs

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Global router configuration
router_host = None
router_port = 52116

class IP3Router:
    def __init__(self, host, port=52116):
        self.host = host
        self.port = port
        self.sock = None
        self.connected = False
        logger.info(f"IP3Router initialized with host {host}:{port}")

    def connect(self):
        #Establish connection to the router.
        if self.connected:
            return True
            
        try:
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.sock.settimeout(5) 
            self.sock.connect((self.host, self.port))
            self.connected = True
            logger.info(f"Connected to router at {self.host}:{self.port}")
            return True
        except (socket.error, ConnectionRefusedError) as e:
            logger.error(f"Failed to connect to router: {str(e)}")
            self.connected = False
            return False

    def ensure_connection(self):
        #Ensure connection is established before operations.
        if not self.connected:
            return self.connect()
        return True

    def clear_buffer(self):
        #Clear any existing data in the socket buffer to prevent mixed responses.
        if not self.ensure_connection():
            return False

        self.sock.settimeout(0.1)
        try:
            while self.sock.recv(4096):
                pass
        except socket.timeout:
            pass
        self.sock.settimeout(None)

    def status(self, dst, retries=3):
        #Send the status command and attempt to get a valid response.
        if not self.ensure_connection():
            return None

        for attempt in range(retries):
            try:
                self.clear_buffer()
                command = f"~XPOINT?D${{{dst}}}\\\n"
                self.sock.sendall(command.encode())

                time.sleep(0.5)

                response = self.sock.recv(4096).decode()

                if f"D${{{dst}}}" in response:
                    match = re.search(r"S\${(.*?)}\\", response)
                    if match:
                        source = match.group(1)
                        logger.info(f"Source '{source}' is routed to Destination '{dst}'")
                        return source
                    else:
                        logger.warning(f"Could not parse source for {dst}. Raw response: '{response.strip()}'")
                        return None

                logger.warning(f"Attempt {attempt + 1} failed. Retrying...")

            except socket.error as e:
                logger.error(f"Socket error during status check: {str(e)}")
                self.connected = False
                if attempt == retries - 1:
                    return None
                time.sleep(1) 

        logger.error(f"Failed to get a valid response for {dst} after {retries} attempts.")
        return None

    def route(self, src, dst, retries=3):
        #route a source to a destination
        for attempt in range(retries):
            self.clear_buffer()
            command = f"~XPOINT:S${{{src}}};D${{{dst}}}\\\n"  
            self.sock.sendall(command.encode())

            time.sleep(0.5)  

            response = self.sock.recv(4096).decode()
            logger.debug(f"Router Response: '{response.strip()}'")

            if "LOCK!D" in response:
                logger.info(f"Destination '{dst}' is locked")
                return "locked" 
                
            current_source = self.status(dst)
            if current_source == src:
                logger.info(f"Successfully routed Source '{src}' to Destination '{dst}'")
                return True
            else:
                logger.warning(f"Attempt {attempt + 1} failed. Unexpected response.")

        logger.error(f"Failed to route Source '{src}' to Destination '{dst}' after {retries} attempts.")
        return False

    def close(self):
        #Close the connection to the router.
        if self.sock:
            self.sock.close()
            self.connected = False
            logger.info("Router connection closed")

    def clear_route(self, src, retries=3):
        #Clear the route for a source.
        if not self.ensure_connection():
            return False

        for attempt in range(retries):
            try:
                self.clear_buffer()
                command = f"~XPOINT%D${{{src}}}\\\n"
                self.sock.sendall(command.encode())

                time.sleep(1.0)

                response = self.sock.recv(4096).decode()
                logger.info(f"Clear Route Response: '{response.strip()}'")

                if "cleared" in response or f"D${{{src}}}" not in response:
                    logger.info(f"Successfully cleared route for Source '{src}'")
                    return True
                else:
                    logger.warning(f"Attempt {attempt + 1} failed. Response: '{response.strip()}'")

            except socket.error as e:
                logger.error(f"Socket error during clear route: {str(e)}")
                self.connected = False
                if attempt == retries - 1:
                    return False
                time.sleep(1)  

        logger.error(f"Failed to clear route for Source '{src}' after {retries} attempts.")
        return False
    
    def lock_destination(self, dst, retries=3):
        #Lock a destination
        for attempt in range(retries):
            self.clear_buffer()
            command = f"LOCK:D${{{dst}}};V${{ON}};U#{{20}}\\\n"
            self.sock.sendall(command.encode())

            time.sleep(0.5)

            response = self.sock.recv(4096).decode()
            print(f"Lock Response: '{response.strip()}'")

            print(f"Lock command sent for destination '{dst}'")
            return True

        return False

    def unlock_destination(self, dst, retries=3):
        #Unlock a destination
        for attempt in range(retries):
            self.clear_buffer()
            command = f"LOCK:D${{{dst}}};V${{OFF}};U#{{20}}\\\n" 
            self.sock.sendall(command.encode())

            time.sleep(0.5)

            response = self.sock.recv(4096).decode()
            print(f"Unlock Response: '{response.strip()}'")

            if response:
                print(f"Successfully unlocked destination '{dst}'")
                return True
            else:
                print(f"Attempt {attempt + 1} failed to unlock destination")

        print(f"Failed to unlock destination '{dst}' after {retries} attempts")
        return False

# HTML template will be decoded from base64 at startup
HTML_TEMPLATE = None

HTML_TEMPLATE_B64 = """PCFET0NUWVBFIGh0bWw+CjxodG1sIGxhbmc9ImVuIj4KPGhlYWQ+CiAgICA8bWV0YSBjaGFyc2V0PSJVVEYtOCI+CiAgICA8bWV0YSBuYW1lPSJ2aWV3cG9ydCIgY29udGVudD0id2lkdGg9ZGV2aWNlLXdpZHRoLCBpbml0aWFsLXNjYWxlPTEuMCI+CiAgICA8dGl0bGU+Um91dGVyIENvbnRyb2wgSW50ZXJmYWNlPC90aXRsZT4KICAgIDxzdHlsZT4KICAgICAgICAvKiBFbWJlZGRlZCBDU1MgKi8KICAgICAgICA6cm9vdCB7CiAgICAgICAgICAgIC0tYmFja2dyb3VuZC1kYXJrOiAjMWExZjJlOwogICAgICAgICAgICAtLXBhbmVsLWJnOiAjMjMyODM2OwogICAgICAgICAgICAtLWJ1dHRvbi1iZzogIzJhMzAzZTsKICAgICAgICAgICAgLS1hY2NlbnQtY3lhbjogIzAwZjBmZjsKICAgICAgICAgICAgLS1hY2NlbnQtcmVkOiAjZmYzYjNiOwogICAgICAgICAgICAtLXRleHQtcHJpbWFyeTogI2ZmZmZmZjsKICAgICAgICAgICAgLS10ZXh0LXNlY29uZGFyeTogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjcpOwogICAgICAgICAgICAtLWJvcmRlci1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjEpOwogICAgICAgIH0KCiAgICAgICAgKiB7CiAgICAgICAgICAgIG1hcmdpbjogMDsKICAgICAgICAgICAgcGFkZGluZzogMDsKICAgICAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDsKICAgICAgICAgICAgZm9udC1mYW1pbHk6IC1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgIlNlZ29lIFVJIiwgUm9ib3RvLCBBcmlhbCwgc2Fucy1zZXJpZjsKICAgICAgICB9CgogICAgICAgIGJvZHkgewogICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1iYWNrZ3JvdW5kLWRhcmspOwogICAgICAgICAgICBjb2xvcjogdmFyKC0tdGV4dC1wcmltYXJ5KTsKICAgICAgICAgICAgbGluZS1oZWlnaHQ6IDEuNTsKICAgICAgICAgICAgbWluLWhlaWdodDogMTAwdmg7CiAgICAgICAgfQoKICAgICAgICAuY29udGFpbmVyIHsKICAgICAgICAgICAgbWF4LXdpZHRoOiAxODAwcHg7CiAgICAgICAgICAgIG1hcmdpbjogMCBhdXRvOwogICAgICAgICAgICBwYWRkaW5nOiAyMHB4OwogICAgICAgIH0KCiAgICAgICAgLyogVG9wIEJhciAqLwogICAgICAgIC50b3AtYmFyIHsKICAgICAgICAgICAgZGlzcGxheTogZmxleDsKICAgICAgICAgICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuOwogICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyOwogICAgICAgICAgICBtYXJnaW4tYm90dG9tOiAyMHB4OwogICAgICAgICAgICBwYWRkaW5nOiAxMHB4IDIwcHg7CiAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLXBhbmVsLWJnKTsKICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogOHB4OwogICAgICAgIH0KCiAgICAgICAgLnN0YXR1cy1pbmRpY2F0b3JzIHsKICAgICAgICAgICAgZGlzcGxheTogZmxleDsKICAgICAgICAgICAgZ2FwOiAyMHB4OwogICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyOwogICAgICAgIH0KCiAgICAgICAgLnN0YXR1cy1pdGVtIHsKICAgICAgICAgICAgZGlzcGxheTogZmxleDsKICAgICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjsKICAgICAgICAgICAgZ2FwOiA4cHg7CiAgICAgICAgfQoKICAgICAgICAuc3RhdHVzLWRvdCB7CiAgICAgICAgICAgIHdpZHRoOiAxMHB4OwogICAgICAgICAgICBoZWlnaHQ6IDEwcHg7CiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDUwJTsKICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tYWNjZW50LXJlZCk7CiAgICAgICAgfQoKICAgICAgICAuc3RhdHVzLWRvdC5hY3RpdmUgewogICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMDBmZjAwOwogICAgICAgIH0KCiAgICAgICAgLnRpbWVzdGFtcCB7CiAgICAgICAgICAgIGNvbG9yOiB2YXIoLS10ZXh0LXNlY29uZGFyeSk7CiAgICAgICAgICAgIGZvbnQtc2l6ZTogMC45ZW07CiAgICAgICAgfQoKICAgICAgICAvKiBNYWluIENvbnRlbnQgTGF5b3V0ICovCiAgICAgICAgLm1haW4tY29udGVudCB7CiAgICAgICAgICAgIGRpc3BsYXk6IGdyaWQ7CiAgICAgICAgICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogYXV0byAxZnIgYXV0byAxZnIgYXV0bzsKICAgICAgICAgICAgZ2FwOiAyMHB4OwogICAgICAgICAgICBoZWlnaHQ6IGNhbGMoMTAwdmggLSAxMjBweCk7CiAgICAgICAgfQoKICAgICAgICAvKiBQYW5lbHMgKi8KICAgICAgICAucGFuZWwgewogICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1wYW5lbC1iZyk7CiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDhweDsKICAgICAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjsKICAgICAgICAgICAgZGlzcGxheTogZmxleDsKICAgICAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjsKICAgICAgICB9CgogICAgICAgIC5wYW5lbC1oZWFkZXIgewogICAgICAgICAgICBwYWRkaW5nOiAxNXB4OwogICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuMik7CiAgICAgICAgfQoKICAgICAgICAucGFuZWwtaGVhZGVyIGgyIHsKICAgICAgICAgICAgZm9udC1zaXplOiAxLjFlbTsKICAgICAgICAgICAgZm9udC13ZWlnaHQ6IDUwMDsKICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMTBweDsKICAgICAgICB9CgogICAgICAgIC5zZWFyY2gtY29udGFpbmVyIHsKICAgICAgICAgICAgZGlzcGxheTogZmxleDsKICAgICAgICAgICAgZ2FwOiAxMHB4OwogICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyOwogICAgICAgIH0KCiAgICAgICAgLnNlYXJjaC1pbnB1dCB7CiAgICAgICAgICAgIGZsZXg6IDE7CiAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWJ1dHRvbi1iZyk7CiAgICAgICAgICAgIGJvcmRlcjogMXB4IHNvbGlkIHZhcigtLWJvcmRlci1jb2xvcik7CiAgICAgICAgICAgIGNvbG9yOiB2YXIoLS10ZXh0LXByaW1hcnkpOwogICAgICAgICAgICBwYWRkaW5nOiA4cHggMTJweDsKICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogNHB4OwogICAgICAgICAgICBmb250LXNpemU6IDAuOWVtOwogICAgICAgIH0KCiAgICAgICAgLnNlYXJjaC1pbnB1dDpmb2N1cyB7CiAgICAgICAgICAgIG91dGxpbmU6IG5vbmU7CiAgICAgICAgICAgIGJvcmRlci1jb2xvcjogdmFyKC0tYWNjZW50LWN5YW4pOwogICAgICAgIH0KCiAgICAgICAgLmNvdW50LWJhZGdlIHsKICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tYnV0dG9uLWJnKTsKICAgICAgICAgICAgcGFkZGluZzogNHB4IDhweDsKICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogNHB4OwogICAgICAgICAgICBmb250LXNpemU6IDAuOGVtOwogICAgICAgICAgICBjb2xvcjogdmFyKC0tdGV4dC1zZWNvbmRhcnkpOwogICAgICAgIH0KCiAgICAgICAgLnBhbmVsLWNvbnRlbnQgewogICAgICAgICAgICBwYWRkaW5nOiAxNXB4OwogICAgICAgICAgICBkaXNwbGF5OiBncmlkOwogICAgICAgICAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IHJlcGVhdCg0LCBtaW5tYXgoMCwgMWZyKSk7CiAgICAgICAgICAgIGdhcDogOHB4OwogICAgICAgICAgICBvdmVyZmxvdy15OiBhdXRvOwogICAgICAgICAgICBmbGV4OiAxOwogICAgICAgICAgICBhbGlnbi1jb250ZW50OiBzdGFydDsKICAgICAgICAgICAganVzdGlmeS1jb250ZW50OiBzdGFydDsKICAgICAgICB9CgogICAgICAgIC8qIEJ1dHRvbnMgKi8KICAgICAgICAuc291cmNlLWJ0biwgLmRlc3RpbmF0aW9uLWJ0biB7CiAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWJ1dHRvbi1iZyk7CiAgICAgICAgICAgIGJvcmRlcjogMXB4IHNvbGlkIHZhcigtLWJvcmRlci1jb2xvcik7CiAgICAgICAgICAgIGNvbG9yOiB2YXIoLS10ZXh0LXByaW1hcnkpOwogICAgICAgICAgICBwYWRkaW5nOiA4cHggMTBweDsKICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogNHB4OwogICAgICAgICAgICBjdXJzb3I6IHBvaW50ZXI7CiAgICAgICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjsKICAgICAgICAgICAgZm9udC1zaXplOiAwLjllbTsKICAgICAgICAgICAgdHJhbnNpdGlvbjogYWxsIDAuMnMgZWFzZTsKICAgICAgICAgICAgd2lkdGg6IDEyMHB4OwogICAgICAgICAgICBoZWlnaHQ6IDQycHg7CiAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7CiAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7CiAgICAgICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyOwogICAgICAgICAgICBvdmVyZmxvdzogaGlkZGVuOwogICAgICAgICAgICB3aGl0ZS1zcGFjZTogbm93cmFwOwogICAgICAgICAgICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpczsKICAgICAgICB9CgogICAgICAgIC5zb3VyY2UtYnRuIHsKICAgICAgICAgICAgYm9yZGVyLWxlZnQ6IDNweCBzb2xpZCB2YXIoLS1hY2NlbnQtY3lhbik7CiAgICAgICAgfQoKICAgICAgICAuZGVzdGluYXRpb24tYnRuIHsKICAgICAgICAgICAgaGVpZ2h0OiA0OHB4OyAKICAgICAgICAgICAgcGFkZGluZzogNHB4IDhweDsKICAgICAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjsKICAgICAgICAgICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuOwogICAgICAgICAgICBib3JkZXItbGVmdDogM3B4IHNvbGlkIHZhcigtLWFjY2VudC1yZWQpOwogICAgICAgIH0KCiAgICAgICAgLnNvdXJjZS1idG46aG92ZXIsIC5kZXN0aW5hdGlvbi1idG46aG92ZXIgewogICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMSk7CiAgICAgICAgfQoKICAgICAgICAuc291cmNlLWJ0bi5zZWxlY3RlZCB7CiAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMjQwLCAyNTUsIDAuMik7CiAgICAgICAgICAgIGJvcmRlci1jb2xvcjogdmFyKC0tYWNjZW50LWN5YW4pOwogICAgICAgIH0KCiAgICAgICAgLmRlc3RpbmF0aW9uLWJ0bi5zZWxlY3RlZCB7CiAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCA1OSwgNTksIDAuMik7CiAgICAgICAgICAgIGJvcmRlci1jb2xvcjogdmFyKC0tYWNjZW50LXJlZCk7CiAgICAgICAgfQoKICAgICAgICAvKiBSb3V0ZSBDb250cm9sIFBhbmVsICovCiAgICAgICAgLnJvdXRlLWNvbnRyb2wtcGFuZWwgewogICAgICAgICAgICBkaXNwbGF5OiBmbGV4OwogICAgICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uOwogICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjsKICAgICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjsgCiAgICAgICAgICAgIHBhZGRpbmc6IDIwcHg7CiAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLXBhbmVsLWJnKTsKICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogOHB4OwogICAgICAgICAgICBtaW4td2lkdGg6IDMwMHB4OwogICAgICAgICAgICBnYXA6IDIwcHg7CiAgICAgICAgfQoKICAgICAgICAuc2VsZWN0aW9uLWRpc3BsYXkgewogICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1idXR0b24tYmcpOwogICAgICAgICAgICBib3JkZXI6IDFweCBzb2xpZCB2YXIoLS1ib3JkZXItY29sb3IpOwogICAgICAgICAgICBib3JkZXItcmFkaXVzOiA0cHg7CiAgICAgICAgICAgIHBhZGRpbmc6IDEwcHg7CiAgICAgICAgICAgIGN1cnNvcjogcG9pbnRlcjsKICAgICAgICAgICAgbWluLWhlaWdodDogODBweDsKICAgICAgICAgICAgbWluLXdpZHRoOiAyMTBweDsKICAgICAgICB9CgogICAgICAgIC5zZWxlY3Rpb24tbGFiZWwgewogICAgICAgICAgICBmb250LXNpemU6IDAuOGVtOwogICAgICAgICAgICBjb2xvcjogdmFyKC0tdGV4dC1zZWNvbmRhcnkpOwogICAgICAgICAgICBtYXJnaW4tYm90dG9tOiA1cHg7CiAgICAgICAgfQoKICAgICAgICAuc2VsZWN0aW9uLXZhbHVlIHsKICAgICAgICAgICAgZm9udC1zaXplOiAxLjJlbTsKICAgICAgICAgICAgbWluLWhlaWdodDogMS41ZW07CiAgICAgICAgfQoKICAgICAgICAudGFrZS1idXR0b24gewogICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1idXR0b24tYmcpOwogICAgICAgICAgICBjb2xvcjogdmFyKC0tdGV4dC1wcmltYXJ5KTsKICAgICAgICAgICAgYm9yZGVyOiAycHggc29saWQgdmFyKC0tYWNjZW50LWN5YW4pOwogICAgICAgICAgICBwYWRkaW5nOiAxNXB4IDQwcHg7CiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDRweDsKICAgICAgICAgICAgY3Vyc29yOiBwb2ludGVyOwogICAgICAgICAgICBmb250LXNpemU6IDEuMmVtOwogICAgICAgICAgICB0cmFuc2l0aW9uOiBhbGwgMC4ycyBlYXNlOwogICAgICAgIH0KCiAgICAgICAgLnRha2UtYnV0dG9uOmhvdmVyIHsKICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAyNDAsIDI1NSwgMC4yKTsKICAgICAgICB9CgogICAgICAgIC50YWtlLWJ1dHRvbi5hY3RpdmUgewogICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1hY2NlbnQtY3lhbik7CiAgICAgICAgICAgIGNvbG9yOiB2YXIoLS1iYWNrZ3JvdW5kLWRhcmspOwogICAgICAgIH0KCiAgICAgICAgLyogQ29udHJvbCBCdXR0b25zICovCiAgICAgICAgLmNvbnRyb2wtYnRuIHsKICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tYnV0dG9uLWJnKTsKICAgICAgICAgICAgYm9yZGVyOiAxcHggc29saWQgdmFyKC0tYm9yZGVyLWNvbG9yKTsKICAgICAgICAgICAgY29sb3I6IHZhcigtLXRleHQtcHJpbWFyeSk7CiAgICAgICAgICAgIHBhZGRpbmc6IDhweCAxMHB4OwogICAgICAgICAgICBib3JkZXItcmFkaXVzOiA0cHg7CiAgICAgICAgICAgIGN1cnNvcjogcG9pbnRlcjsKICAgICAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyOwogICAgICAgICAgICBmb250LXNpemU6IDAuOWVtOwogICAgICAgICAgICB0cmFuc2l0aW9uOiBhbGwgMC4ycyBlYXNlOwogICAgICAgICAgICB3aWR0aDogMTIwcHg7CiAgICAgICAgICAgIGhlaWdodDogNDJweDsKICAgICAgICAgICAgZGlzcGxheTogZmxleDsKICAgICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjsKICAgICAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7CiAgICAgICAgICAgIG92ZXJmbG93OiBoaWRkZW47CiAgICAgICAgICAgIHdoaXRlLXNwYWNlOiBub3dyYXA7CiAgICAgICAgICAgIHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzOwogICAgICAgICAgICBib3JkZXItbGVmdDogM3B4IHNvbGlkIHZhcigtLWFjY2VudC1jeWFuKTsKICAgICAgICB9CgogICAgICAgIC5jb250cm9sLWJ0bjpob3ZlciB7CiAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMjQwLCAyNTUsIDAuMSk7CiAgICAgICAgfQoKICAgICAgICAuY29udHJvbC1idG4uc2VsZWN0ZWQgewogICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1hY2NlbnQtY3lhbik7CiAgICAgICAgICAgIGNvbG9yOiB2YXIoLS1iYWNrZ3JvdW5kLWRhcmspOwogICAgICAgIH0KCiAgICAgICAgLyogQ2F0ZWdvcnkgYnV0dG9ucyAqLwogICAgICAgIC5jYXRlZ29yeS1idXR0b25zIHsKICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tcGFuZWwtYmcpOwogICAgICAgICAgICBib3JkZXItcmFkaXVzOiA4cHg7CiAgICAgICAgICAgIHBhZGRpbmc6IDE1cHg7CiAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7CiAgICAgICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47CiAgICAgICAgICAgIGdhcDogMTBweDsKICAgICAgICAgICAgbWF4LXdpZHRoOiAxNTBweDsKICAgICAgICAgICAgb3ZlcmZsb3cteTogYXV0bzsKICAgICAgICB9CgogICAgICAgIC5jYXRlZ29yeS1idG4gewogICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1idXR0b24tYmcpOwogICAgICAgICAgICBib3JkZXI6IDFweCBzb2xpZCB2YXIoLS1ib3JkZXItY29sb3IpOwogICAgICAgICAgICBjb2xvcjogdmFyKC0tdGV4dC1wcmltYXJ5KTsKICAgICAgICAgICAgcGFkZGluZzogOHB4IDEycHg7CiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDRweDsKICAgICAgICAgICAgY3Vyc29yOiBwb2ludGVyOwogICAgICAgICAgICB0ZXh0LWFsaWduOiBsZWZ0OwogICAgICAgICAgICB0cmFuc2l0aW9uOiBhbGwgMC4ycyBlYXNlOwogICAgICAgIH0KCiAgICAgICAgLmNhdGVnb3J5LWJ0bjpob3ZlciB7CiAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4xKTsKICAgICAgICB9CgogICAgICAgIC5jYXRlZ29yeS1idG4uYWN0aXZlIHsKICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tYWNjZW50LWN5YW4pOwogICAgICAgICAgICBjb2xvcjogdmFyKC0tYmFja2dyb3VuZC1kYXJrKTsKICAgICAgICB9CgogICAgICAgIC8qIExvY2sgc3RhdHVzIG1lc3NhZ2UgKi8KICAgICAgICAubG9jay1tZXNzYWdlIHsKICAgICAgICAgICAgZGlzcGxheTogbm9uZTsKICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogIzIzMjgzNjsKICAgICAgICAgICAgY29sb3I6IHZhcigtLWFjY2VudC1yZWQpOwogICAgICAgICAgICBwYWRkaW5nOiAxMHB4OwogICAgICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7CiAgICAgICAgICAgIGJvcmRlcjogc29saWQ7CiAgICAgICAgICAgIGJvcmRlci1jb2xvcjogdmFyKC0tYWNjZW50LXJlZCk7CiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDRweDsKICAgICAgICAgICAgbWFyZ2luLXRvcDogMTBweDsKICAgICAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7CiAgICAgICAgICAgIG1heC13aWR0aDogMjYwcHg7CiAgICAgICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTsKICAgICAgICAgICAgYm90dG9tOiAzMHB4OwogICAgICAgIH0KCiAgICAgICAgLmxvY2stbWVzc2FnZS52aXNpYmxlIHsKICAgICAgICAgICAgZGlzcGxheTogYmxvY2s7CiAgICAgICAgfQoKICAgICAgICAvKiBJbmZvIEJ1dHRvbiAqLwogICAgICAgIC5pbmZvLWJ1dHRvbiB7CiAgICAgICAgICAgIHBvc2l0aW9uOiBmaXhlZDsKICAgICAgICAgICAgYm90dG9tOiAyMHB4OwogICAgICAgICAgICByaWdodDogMjBweDsKICAgICAgICAgICAgd2lkdGg6IDQwcHg7CiAgICAgICAgICAgIGhlaWdodDogNDBweDsKICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogNTAlOwogICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1idXR0b24tYmcpOwogICAgICAgICAgICBjb2xvcjogdmFyKC0tYWNjZW50LWN5YW4pOwogICAgICAgICAgICBib3JkZXI6IDJweCBzb2xpZCB2YXIoLS1hY2NlbnQtY3lhbik7CiAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7CiAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7CiAgICAgICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyOwogICAgICAgICAgICBmb250LXNpemU6IDIwcHg7CiAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkOwogICAgICAgICAgICBjdXJzb3I6IHBvaW50ZXI7CiAgICAgICAgICAgIHotaW5kZXg6IDEwMDsKICAgICAgICAgICAgdHJhbnNpdGlvbjogYWxsIDAuMnMgZWFzZTsKICAgICAgICB9CiAgICAgICAgCiAgICAgICAgLmluZm8tYnV0dG9uOmhvdmVyIHsKICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tYWNjZW50LWN5YW4pOwogICAgICAgICAgICBjb2xvcjogdmFyKC0tYmFja2dyb3VuZC1kYXJrKTsKICAgICAgICB9CiAgICAgICAgCiAgICAgICAgLyogTW9kYWwgUG9wdXAgKi8KICAgICAgICAubW9kYWwgewogICAgICAgICAgICBkaXNwbGF5OiBub25lOwogICAgICAgICAgICBwb3NpdGlvbjogZml4ZWQ7CiAgICAgICAgICAgIHRvcDogMDsKICAgICAgICAgICAgbGVmdDogMDsKICAgICAgICAgICAgd2lkdGg6IDEwMCU7CiAgICAgICAgICAgIGhlaWdodDogMTAwJTsKICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwLjcpOwogICAgICAgICAgICB6LWluZGV4OiAxMDAwOwogICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyOwogICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjsKICAgICAgICB9CiAgICAgICAgCiAgICAgICAgLm1vZGFsLnZpc2libGUgewogICAgICAgICAgICBkaXNwbGF5OiBmbGV4OwogICAgICAgIH0KICAgICAgICAKICAgICAgICAubW9kYWwtY29udGVudCB7CiAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLXBhbmVsLWJnKTsKICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogOHB4OwogICAgICAgICAgICBwYWRkaW5nOiAzMHB4OwogICAgICAgICAgICBtYXgtd2lkdGg6IDYwMHB4OwogICAgICAgICAgICB3aWR0aDogODAlOwogICAgICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7CiAgICAgICAgICAgIGJveC1zaGFkb3c6IDAgNHB4IDIwcHggcmdiYSgwLCAwLCAwLCAwLjUpOwogICAgICAgIH0KICAgICAgICAKICAgICAgICAubW9kYWwtY2xvc2UgewogICAgICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7CiAgICAgICAgICAgIHRvcDogMTBweDsKICAgICAgICAgICAgcmlnaHQ6IDE1cHg7CiAgICAgICAgICAgIGZvbnQtc2l6ZTogMjRweDsKICAgICAgICAgICAgY3Vyc29yOiBwb2ludGVyOwogICAgICAgICAgICBjb2xvcjogdmFyKC0tdGV4dC1zZWNvbmRhcnkpOwogICAgICAgIH0KICAgICAgICAKICAgICAgICAubW9kYWwtY2xvc2U6aG92ZXIgewogICAgICAgICAgICBjb2xvcjogdmFyKC0tdGV4dC1wcmltYXJ5KTsKICAgICAgICB9CiAgICAgICAgCiAgICAgICAgLm1vZGFsLXRpdGxlIHsKICAgICAgICAgICAgZm9udC1zaXplOiAxLjRlbTsKICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMjBweDsKICAgICAgICAgICAgY29sb3I6IHZhcigtLWFjY2VudC1jeWFuKTsKICAgICAgICB9CiAgICAgICAgCiAgICAgICAgLm1vZGFsLXRleHQgewogICAgICAgICAgICBsaW5lLWhlaWdodDogMS42OwogICAgICAgICAgICB3aGl0ZS1zcGFjZTogcHJlLWxpbmU7CiAgICAgICAgfQogICAgICAgIAogICAgICAgIC8qIFNpbXVsYXRpb24gQmFubmVyICovCiAgICAgICAgLnNpbXVsYXRpb24tYmFubmVyIHsKICAgICAgICAgICAgcG9zaXRpb246IGZpeGVkOwogICAgICAgICAgICBib3R0b206IDA7CiAgICAgICAgICAgIGxlZnQ6IDA7CiAgICAgICAgICAgIHJpZ2h0OiAwOwogICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1hY2NlbnQtcmVkKTsKICAgICAgICAgICAgY29sb3I6IHdoaXRlOwogICAgICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7CiAgICAgICAgICAgIHBhZGRpbmc6IDhweDsKICAgICAgICAgICAgZm9udC13ZWlnaHQ6IDUwMDsKICAgICAgICB9CgogICAgICAgIC8qIEhpZGRlbiBDbGFzcyAqLwogICAgICAgIC5oaWRkZW4gewogICAgICAgICAgICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7CiAgICAgICAgfQoKICAgICAgICAvKiBTY3JvbGxiYXIgU3R5bGluZyAqLwogICAgICAgIDo6LXdlYmtpdC1zY3JvbGxiYXIgewogICAgICAgICAgICB3aWR0aDogOHB4OwogICAgICAgIH0KCiAgICAgICAgOjotd2Via2l0LXNjcm9sbGJhci10cmFjayB7CiAgICAgICAgICAgIGJhY2tncm91bmQ6IHZhcigtLWJ1dHRvbi1iZyk7CiAgICAgICAgfQoKICAgICAgICA6Oi13ZWJraXQtc2Nyb2xsYmFyLXRodW1iIHsKICAgICAgICAgICAgYmFja2dyb3VuZDogdmFyKC0tYm9yZGVyLWNvbG9yKTsKICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogNHB4OwogICAgICAgIH0KCiAgICAgICAgOjotd2Via2l0LXNjcm9sbGJhci10aHVtYjpob3ZlciB7CiAgICAgICAgICAgIGJhY2tncm91bmQ6IHZhcigtLXRleHQtc2Vjb25kYXJ5KTsKICAgICAgICB9CiAgICA8L3N0eWxlPgo8L2hlYWQ+Cjxib2R5PgogICAgPGRpdiBjbGFzcz0iY29udGFpbmVyIj4KICAgICAgICA8ZGl2IGNsYXNzPSJ0b3AtYmFyIj4KICAgICAgICAgICAgPGRpdiBjbGFzcz0ic3RhdHVzLWluZGljYXRvcnMiPgogICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0ic3RhdHVzLWl0ZW0iPgogICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSJzdGF0dXMtZG90IHtyb3V0ZXJfc3RhdHVzfSI+PC9zcGFuPgogICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSJzdGF0dXMtbGFiZWwiPlJvdXRlciBDb25uZWN0aW9uIFN0YXR1czwvc3Bhbj4KICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0idGltZXN0YW1wIj57dGltZXN0YW1wfTwvZGl2PgogICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgPGRpdiBjbGFzcz0icm91dGVyLWNvbnRyb2xzIj4KICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9ImNvbnRyb2wtYnRuIiBkYXRhLXNvdXJjZT0iSEQtQkFSUyI+SEQgQkFSUzwvYnV0dG9uPgogICAgICAgICAgICA8L2Rpdj4KICAgICAgICA8L2Rpdj4KCiAgICAgICAgPGRpdiBjbGFzcz0ibWFpbi1jb250ZW50Ij4KICAgICAgICAgICAgPCEtLSBTb3VyY2UgQ2F0ZWdvcmllcyAtLT4KICAgICAgICAgICAgPGRpdiBjbGFzcz0iY2F0ZWdvcnktYnV0dG9ucyBzb3VyY2VzIj4KICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9ImNhdGVnb3J5LWJ0biBhY3RpdmUiIGRhdGEtY2F0ZWdvcnk9ImFsbCI+QWxsIFNvdXJjZXM8L2J1dHRvbj4KICAgICAgICAgICAgICAgIHtzb3VyY2VfY2F0ZWdvcmllc30KICAgICAgICAgICAgPC9kaXY+CgogICAgICAgICAgICA8IS0tIFNvdXJjZXMgUGFuZWwgLS0+CiAgICAgICAgICAgIDxkaXYgY2xhc3M9InBhbmVsIHNvdXJjZXMtcGFuZWwiPgogICAgICAgICAgICAgICAgPGgyPlNPVVJDRVM8L2gyPgogICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0ic2VhcmNoLWNvbnRhaW5lciI+CiAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9InRleHQiIGlkPSJzb3VyY2Utc2VhcmNoIiBjbGFzcz0ic2VhcmNoLWlucHV0IiBwbGFjZWhvbGRlcj0iU2VhcmNoIHNvdXJjZXMuLi4iPgogICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImNvdW50LWJhZGdlIiBpZD0ic291cmNlLWNvdW50Ij4wLzA8L2Rpdj4KICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0icGFuZWwtY29udGVudCIgaWQ9InNvdXJjZXMtZ3JpZCI+CiAgICAgICAgICAgICAgICAgICAge3NvdXJjZXN9CiAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgPC9kaXY+CgogICAgICAgICAgICA8IS0tIFJvdXRlIENvbnRyb2wgUGFuZWwgLS0+CiAgICAgICAgICAgIDxkaXYgY2xhc3M9InJvdXRlLWNvbnRyb2wtcGFuZWwiPgogICAgICAgICAgICAgICAgPGRpdiBpZD0ic2VsZWN0ZWQtc291cmNlIiBjbGFzcz0ic2VsZWN0aW9uLWRpc3BsYXkiPgogICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InNlbGVjdGlvbi1sYWJlbCI+U09VUkNFPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0ic2VsZWN0aW9uLXZhbHVlIj48L2Rpdj4KICAgICAgICAgICAgICAgIDwvZGl2PgoKICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InRha2UtYnV0dG9uLWNvbnRhaW5lciI+CiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz0idGFrZS1idXR0b24iPlRBS0U8L2J1dHRvbj4KICAgICAgICAgICAgICAgIDwvZGl2PgoKICAgICAgICAgICAgICAgIDxkaXYgaWQ9InNlbGVjdGVkLWRlc3RpbmF0aW9uIiBjbGFzcz0ic2VsZWN0aW9uLWRpc3BsYXkiPgogICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InNlbGVjdGlvbi1sYWJlbCI+REVTVElOQVRJT048L2Rpdj4KICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJzZWxlY3Rpb24tdmFsdWUiPjwvZGl2PgogICAgICAgICAgICAgICAgPC9kaXY+CgogICAgICAgICAgICAgICAgPGRpdiBpZD0ibG9jay1tZXNzYWdlIiBjbGFzcz0ibG9jay1tZXNzYWdlIj4KICAgICAgICAgICAgICAgICAgICBEZXN0aW5hdGlvbiBpcyBsb2NrZWQsIGNvbnRhY3QgRW5naW5lZXJpbmcKICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICA8L2Rpdj4KCiAgICAgICAgICAgIDwhLS0gRGVzdGluYXRpb25zIFBhbmVsIC0tPgogICAgICAgICAgICA8ZGl2IGNsYXNzPSJwYW5lbCBkZXN0aW5hdGlvbnMtcGFuZWwiPgogICAgICAgICAgICAgICAgPGgyPkRFU1RJTkFUSU9OUzwvaDI+CiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJzZWFyY2gtY29udGFpbmVyIj4KICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT0idGV4dCIgaWQ9ImRlc3RpbmF0aW9uLXNlYXJjaCIgY2xhc3M9InNlYXJjaC1pbnB1dCIgcGxhY2Vob2xkZXI9IlNlYXJjaCBkZXN0aW5hdGlvbnMuLi4iPgogICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImNvdW50LWJhZGdlIiBpZD0iZGVzdGluYXRpb24tY291bnQiPjAvMDwvZGl2PgogICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJwYW5lbC1jb250ZW50IiBpZD0iZGVzdGluYXRpb25zLWdyaWQiPgogICAgICAgICAgICAgICAgICAgIHtkZXN0aW5hdGlvbnN9CiAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgPC9kaXY+CgogICAgICAgICAgICA8IS0tIERlc3RpbmF0aW9uIENhdGVnb3JpZXMgLS0+CiAgICAgICAgICAgIDxkaXYgY2xhc3M9ImNhdGVnb3J5LWJ1dHRvbnMgZGVzdGluYXRpb25zIj4KICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9ImNhdGVnb3J5LWJ0biBhY3RpdmUiIGRhdGEtY2F0ZWdvcnk9ImFsbCI+QWxsIERlc3RpbmF0aW9uczwvYnV0dG9uPgogICAgICAgICAgICAgICAge2Rlc3RpbmF0aW9uX2NhdGVnb3JpZXN9CiAgICAgICAgICAgIDwvZGl2PgogICAgICAgIDwvZGl2PgoKICAgICAgICB7c2ltdWxhdGlvbl9iYW5uZXJ9CiAgICAgICAgCiAgICAgICAgPCEtLSBJbmZvIEJ1dHRvbiAtLT4KICAgICAgICA8YnV0dG9uIGNsYXNzPSJpbmZvLWJ1dHRvbiI+aTwvYnV0dG9uPgogICAgICAgIAogICAgICAgIDwhLS0gSW5mbyBNb2RhbCAtLT4KICAgICAgICA8ZGl2IGlkPSJpbmZvLW1vZGFsIiBjbGFzcz0ibW9kYWwiPgogICAgICAgICAgICA8ZGl2IGNsYXNzPSJtb2RhbC1jb250ZW50Ij4KICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSJtb2RhbC1jbG9zZSI+JnRpbWVzOzwvc3Bhbj4KICAgICAgICAgICAgICAgIDxoMyBjbGFzcz0ibW9kYWwtdGl0bGUiPkhhcnJpcyBMUkMgQ29udHJvbCBJbnRlcmZhY2U8L2gzPgogICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0ibW9kYWwtdGV4dCI+CiAgICAgICAgICAgICAgICAgICAgQSB3ZWItYmFzZWQgY29udHJvbCBpbnRlcmZhY2UgZm9yIEhhcnJpcyBMUkMgc3lzdGVtcy4gVGhpcyBhcHBsaWNhdGlvbiBwcm92aWRlcyB3ZWIgaW50ZXJmYWNlIGZvciBtYW5hZ2luZyB2aWRlbyByb3V0aW5nLCBtb25pdG9yaW5nIHJvdXRlciBzdGF0dXMsIGFuZCBjb250cm9sbGluZyBkZXN0aW5hdGlvbiBsb2NrcyBvbiBIYXJyaXMgTFJDIHJvdXRlcnMuCgogICAgICAgICAgICAgICAgICAgIFBhcnQgb2YgU0JDUy4KICAgICAgICAgICAgICAgICAgICAyMDI1IEJlbiBDb3N0ZXJ0b24gLSBodHRwczovL2dpdGh1Yi5jb20vQmVuY29zdGVydG9uLwoKICAgICAgICAgICAgICAgICAgICBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkIGFzLWlzIGZvciBjb250cm9sbGluZyBIYXJyaXMgTFJDIHJvdXRlciBzeXN0ZW1zLiBQbGVhc2UgZW5zdXJlIGNvbXBsaWFuY2Ugd2l0aCB5b3VyIG9yZ2FuaXphdGlvbidzIG5ldHdvcmsgYW5kIGVxdWlwbWVudCBwb2xpY2llcyBiZWZvcmUgZGVwbG95bWVudC4KICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICA8L2Rpdj4KICAgICAgICA8L2Rpdj4KICAgIDwvZGl2PgoKICAgIDxzY3JpcHQ+CiAgICAgICAgLy8gRW1iZWRkZWQgSmF2YVNjcmlwdAogICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBmdW5jdGlvbigpIHsKICAgICAgICAgICAgbGV0IHNlbGVjdGVkU291cmNlID0gbnVsbDsKICAgICAgICAgICAgbGV0IHNlbGVjdGVkRGVzdGluYXRpb24gPSBudWxsOwoKICAgICAgICAgICAgLy8gR2V0IHRoZSB0aW1lCiAgICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVRpbWVzdGFtcCgpIHsKICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVzdGFtcEVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcudGltZXN0YW1wJyk7CiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZSgpIHsKICAgICAgICAgICAgICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpOwogICAgICAgICAgICAgICAgICAgIGNvbnN0IGZvcm1hdHRlZERhdGUgPSBub3cudG9Mb2NhbGVEYXRlU3RyaW5nKCdlbi1HQicpOwogICAgICAgICAgICAgICAgICAgIGNvbnN0IGZvcm1hdHRlZFRpbWUgPSBub3cudG9Mb2NhbGVUaW1lU3RyaW5nKCdlbi1HQicsIHsgCiAgICAgICAgICAgICAgICAgICAgICAgIGhvdXI6ICcyLWRpZ2l0JywgCiAgICAgICAgICAgICAgICAgICAgICAgIG1pbnV0ZTogJzItZGlnaXQnLAogICAgICAgICAgICAgICAgICAgICAgICBzZWNvbmQ6ICcyLWRpZ2l0JwogICAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcEVsZW1lbnQudGV4dENvbnRlbnQgPSBgJHtmb3JtYXR0ZWREYXRlfSAke2Zvcm1hdHRlZFRpbWV9YDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgCiAgICAgICAgICAgICAgICB1cGRhdGUoKTsKICAgICAgICAgICAgICAgIHNldEludGVydmFsKHVwZGF0ZSwgMTAwMCk7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIC8vIFNlYXJjaCBmdW5jdGlvbmFsaXR5CiAgICAgICAgICAgIGZ1bmN0aW9uIHNldHVwU2VhcmNoKHNlYXJjaElkLCBidXR0b25DbGFzcywgY291bnRJZCkgewogICAgICAgICAgICAgICAgY29uc3Qgc2VhcmNoSW5wdXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzZWFyY2hJZCk7CiAgICAgICAgICAgICAgICBjb25zdCBjb3VudERpc3BsYXkgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjb3VudElkKTsKICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgZnVuY3Rpb24gdXBkYXRlQ291bnQoKSB7CiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG90YWxCdXR0b25zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChgLiR7YnV0dG9uQ2xhc3N9YCkubGVuZ3RoOwogICAgICAgICAgICAgICAgICAgIGNvbnN0IHZpc2libGVCdXR0b25zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChgLiR7YnV0dG9uQ2xhc3N9Om5vdCguaGlkZGVuKWApLmxlbmd0aDsKICAgICAgICAgICAgICAgICAgICBjb3VudERpc3BsYXkudGV4dENvbnRlbnQgPSBgJHt2aXNpYmxlQnV0dG9uc30vJHt0b3RhbEJ1dHRvbnN9YDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgdXBkYXRlQ291bnQoKTsKICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgc2VhcmNoSW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBmdW5jdGlvbigpIHsKICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWFyY2hUZXJtID0gdGhpcy52YWx1ZS50b0xvd2VyQ2FzZSgpOwogICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYC4ke2J1dHRvbkNsYXNzfWApLmZvckVhY2goYnRuID0+IHsKICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGV4dCA9IGJ0bi50ZXh0Q29udGVudC50b0xvd2VyQ2FzZSgpOwogICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc1Zpc2libGUgPSB0ZXh0LmluY2x1ZGVzKHNlYXJjaFRlcm0pOwogICAgICAgICAgICAgICAgICAgICAgICBidG4uY2xhc3NMaXN0LnRvZ2dsZSgnaGlkZGVuJywgIWlzVmlzaWJsZSk7CiAgICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgdXBkYXRlQ291bnQoKTsKICAgICAgICAgICAgICAgIH0pOwoKICAgICAgICAgICAgICAgIC8vIENsZWFyIHNlYXJjaAogICAgICAgICAgICAgICAgZnVuY3Rpb24gY2xlYXJTZWFyY2goKSB7CiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChgLiR7YnV0dG9uQ2xhc3N9YCkuZm9yRWFjaChidG4gPT4gewogICAgICAgICAgICAgICAgICAgICAgICBidG4uY2xhc3NMaXN0LnJlbW92ZSgnaGlkZGVuJyk7CiAgICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICAgICAgdXBkYXRlQ291bnQoKTsKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICBzZWFyY2hJbnB1dC5hZGRFdmVudExpc3RlbmVyKCdzZWFyY2gnLCBmdW5jdGlvbigpIHsKICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy52YWx1ZSA9PT0gJycpIHsKICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJTZWFyY2goKTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9KTsKCiAgICAgICAgICAgICAgICBzZWFyY2hJbnB1dC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZnVuY3Rpb24oZSkgewogICAgICAgICAgICAgICAgICAgIGlmIChlLmtleSA9PT0gJ0VzY2FwZScpIHsKICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9ICcnOwogICAgICAgICAgICAgICAgICAgICAgICBjbGVhclNlYXJjaCgpOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICB9CgogICAgICAgICAgICAvLyBDYXRlZ29yeSBmdW5jdGlvbmFsaXR5CiAgICAgICAgICAgIGZ1bmN0aW9uIGluaXRpYWxpemVDYXRlZ29yaWVzKCkgewogICAgICAgICAgICAgICAgLy8gU291cmNlIGNhdGVnb3JpZXMKICAgICAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5jYXRlZ29yeS1idXR0b25zLnNvdXJjZXMgLmNhdGVnb3J5LWJ0bicpLmZvckVhY2goYnRuID0+IHsKICAgICAgICAgICAgICAgICAgICBidG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbigpIHsKICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2F0ZWdvcnkgPSB0aGlzLmRhdGFzZXQuY2F0ZWdvcnk7CiAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAvLyBUb2dnbGUgYWN0aXZlIHN0YXRlCiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5jYXRlZ29yeS1idXR0b25zLnNvdXJjZXMgLmNhdGVnb3J5LWJ0bicpLmZvckVhY2goYiA9PiAKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJykpOwogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpOwogICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmlsdGVyIHNvdXJjZXMKICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnNvdXJjZS1idG4nKS5mb3JFYWNoKHNvdXJjZUJ0biA9PiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2F0ZWdvcnkgPT09ICdhbGwnIHx8IHNvdXJjZUJ0bi5kYXRhc2V0LmNhdGVnb3JpZXMuaW5jbHVkZXMoY2F0ZWdvcnkpKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlQnRuLmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VCdG4uY2xhc3NMaXN0LmFkZCgnaGlkZGVuJyk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY291bnREaXNwbGF5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NvdXJjZS1jb3VudCcpOwogICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b3RhbEJ1dHRvbnMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuc291cmNlLWJ0bicpLmxlbmd0aDsKICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmlzaWJsZUJ1dHRvbnMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuc291cmNlLWJ0bjpub3QoLmhpZGRlbiknKS5sZW5ndGg7CiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50RGlzcGxheS50ZXh0Q29udGVudCA9IGAke3Zpc2libGVCdXR0b25zfS8ke3RvdGFsQnV0dG9uc31gOwogICAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgfSk7CgogICAgICAgICAgICAgICAgLy8gRGVzdGluYXRpb24gY2F0ZWdvcmllcwogICAgICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmNhdGVnb3J5LWJ1dHRvbnMuZGVzdGluYXRpb25zIC5jYXRlZ29yeS1idG4nKS5mb3JFYWNoKGJ0biA9PiB7CiAgICAgICAgICAgICAgICAgICAgYnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhdGVnb3J5ID0gdGhpcy5kYXRhc2V0LmNhdGVnb3J5OwogICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgLy8gVG9nZ2xlIGFjdGl2ZSBzdGF0ZQogICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuY2F0ZWdvcnktYnV0dG9ucy5kZXN0aW5hdGlvbnMgLmNhdGVnb3J5LWJ0bicpLmZvckVhY2goYiA9PiAKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJykpOwogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpOwogICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmlsdGVyIGRlc3RpbmF0aW9ucwogICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZGVzdGluYXRpb24tYnRuJykuZm9yRWFjaChkZXN0QnRuID0+IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYXRlZ29yeSA9PT0gJ2FsbCcgfHwgZGVzdEJ0bi5kYXRhc2V0LmNhdGVnb3JpZXMuaW5jbHVkZXMoY2F0ZWdvcnkpKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzdEJ0bi5jbGFzc0xpc3QucmVtb3ZlKCdoaWRkZW4nKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzdEJ0bi5jbGFzc0xpc3QuYWRkKCdoaWRkZW4nKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb3VudERpc3BsYXkgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGVzdGluYXRpb24tY291bnQnKTsKICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG90YWxCdXR0b25zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmRlc3RpbmF0aW9uLWJ0bicpLmxlbmd0aDsKICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmlzaWJsZUJ1dHRvbnMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZGVzdGluYXRpb24tYnRuOm5vdCguaGlkZGVuKScpLmxlbmd0aDsKICAgICAgICAgICAgICAgICAgICAgICAgY291bnREaXNwbGF5LnRleHRDb250ZW50ID0gYCR7dmlzaWJsZUJ1dHRvbnN9LyR7dG90YWxCdXR0b25zfWA7CiAgICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgLy8gUm91dGVyIHN0YXR1cyBmdW5jdGlvbmFsaXR5CiAgICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZURlc3RpbmF0aW9uU3RhdHVzKGRlc3RpbmF0aW9uKSB7CiAgICAgICAgICAgICAgICBjb25zdCBidG4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGAuZGVzdGluYXRpb24tYnRuW2RhdGEtZGVzdGluYXRpb249IiR7ZGVzdGluYXRpb259Il1gKTsKICAgICAgICAgICAgICAgIGlmICghYnRuKSByZXR1cm47CgogICAgICAgICAgICAgICAgZmV0Y2goYC9zdGF0dXMvJHtkZXN0aW5hdGlvbn1gKQogICAgICAgICAgICAgICAgICAgIC50aGVuKHJlc3BvbnNlID0+IHJlc3BvbnNlLmpzb24oKSkKICAgICAgICAgICAgICAgICAgICAudGhlbihkYXRhID0+IHsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkRGVzdGluYXRpb24gPT09IGRlc3RpbmF0aW9uICYmIGRhdGEuc291cmNlKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2VCdG4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGAuc291cmNlLWJ0bltkYXRhLXNvdXJjZT0iJHtkYXRhLnNvdXJjZX0iXWApOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuc291cmNlID09PSAnSEQtQkFSUycpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RTb3VyY2UoJ0hELUJBUlMnLCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY29udHJvbC1idG5bZGF0YS1zb3VyY2U9IkhELUJBUlMiXScpKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlQnRuKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0U291cmNlKGRhdGEuc291cmNlLCBzb3VyY2VCdG4pOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfSkKICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZXJyb3IgPT4gewogICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIHN0YXR1czonLCBlcnJvcik7CiAgICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIC8vIFNlbGVjdGlvbiBmdW5jdGlvbmFsaXR5CiAgICAgICAgICAgIGZ1bmN0aW9uIHNlbGVjdFNvdXJjZShzb3VyY2UsIGJ1dHRvbkVsZW1lbnQpIHsKICAgICAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5zb3VyY2UtYnRuLCAuY29udHJvbC1idG4nKS5mb3JFYWNoKGIgPT4gYi5jbGFzc0xpc3QucmVtb3ZlKCdzZWxlY3RlZCcpKTsKICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgaWYgKGJ1dHRvbkVsZW1lbnQpIHsKICAgICAgICAgICAgICAgICAgICBidXR0b25FbGVtZW50LmNsYXNzTGlzdC5hZGQoJ3NlbGVjdGVkJyk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgIHNlbGVjdGVkU291cmNlID0gc291cmNlOwogICAgICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3NlbGVjdGVkLXNvdXJjZSAuc2VsZWN0aW9uLXZhbHVlJykudGV4dENvbnRlbnQgPSBzb3VyY2U7CiAgICAgICAgICAgICAgICB1cGRhdGVUYWtlQnV0dG9uKCk7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGZ1bmN0aW9uIHJlc2V0U2VsZWN0aW9ucygpIHsKICAgICAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5zb3VyY2UtYnRuLCAuY29udHJvbC1idG4nKS5mb3JFYWNoKGJ0biA9PiBidG4uY2xhc3NMaXN0LnJlbW92ZSgnc2VsZWN0ZWQnKSk7CiAgICAgICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZGVzdGluYXRpb24tYnRuJykuZm9yRWFjaChidG4gPT4gYnRuLmNsYXNzTGlzdC5yZW1vdmUoJ3NlbGVjdGVkJykpOwogICAgICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3NlbGVjdGVkLXNvdXJjZSAuc2VsZWN0aW9uLXZhbHVlJykudGV4dENvbnRlbnQgPSAnJzsKICAgICAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNzZWxlY3RlZC1kZXN0aW5hdGlvbiAuc2VsZWN0aW9uLXZhbHVlJykudGV4dENvbnRlbnQgPSAnJzsKICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsb2NrLW1lc3NhZ2UnKS5jbGFzc0xpc3QucmVtb3ZlKCd2aXNpYmxlJyk7CiAgICAgICAgICAgICAgICBzZWxlY3RlZFNvdXJjZSA9IG51bGw7CiAgICAgICAgICAgICAgICBzZWxlY3RlZERlc3RpbmF0aW9uID0gbnVsbDsKICAgICAgICAgICAgICAgIHVwZGF0ZVRha2VCdXR0b24oKTsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgZnVuY3Rpb24gdXBkYXRlVGFrZUJ1dHRvbigpIHsKICAgICAgICAgICAgICAgIGNvbnN0IHRha2VCdXR0b24gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcudGFrZS1idXR0b24nKTsKICAgICAgICAgICAgICAgIGlmIChzZWxlY3RlZFNvdXJjZSAmJiBzZWxlY3RlZERlc3RpbmF0aW9uKSB7CiAgICAgICAgICAgICAgICAgICAgdGFrZUJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTsKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgdGFrZUJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQoKICAgICAgICAgICAgLy8gRXZlbnQgTGlzdGVuZXJzCiAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5zb3VyY2UtYnRuJykuZm9yRWFjaChidG4gPT4gewogICAgICAgICAgICAgICAgYnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgICAgICAgc2VsZWN0U291cmNlKHRoaXMuZGF0YXNldC5zb3VyY2UsIHRoaXMpOwogICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIH0pOwogICAgICAgICAgICAKICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmRlc3RpbmF0aW9uLWJ0bicpLmZvckVhY2goYnRuID0+IHsKICAgICAgICAgICAgICAgIGJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5kZXN0aW5hdGlvbi1idG4nKS5mb3JFYWNoKGIgPT4gYi5jbGFzc0xpc3QucmVtb3ZlKCdzZWxlY3RlZCcpKTsKICAgICAgICAgICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ3NlbGVjdGVkJyk7CiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWREZXN0aW5hdGlvbiA9IHRoaXMuZGF0YXNldC5kZXN0aW5hdGlvbjsKICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjc2VsZWN0ZWQtZGVzdGluYXRpb24gLnNlbGVjdGlvbi12YWx1ZScpLnRleHRDb250ZW50ID0gc2VsZWN0ZWREZXN0aW5hdGlvbjsKICAgICAgICAgICAgICAgICAgICB1cGRhdGVUYWtlQnV0dG9uKCk7CiAgICAgICAgICAgICAgICAgICAgdXBkYXRlRGVzdGluYXRpb25TdGF0dXMoc2VsZWN0ZWREZXN0aW5hdGlvbik7CiAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgfSk7CgogICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2VsZWN0ZWQtc291cmNlJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbigpIHsKICAgICAgICAgICAgICAgIHNlbGVjdGVkU291cmNlID0gbnVsbDsKICAgICAgICAgICAgICAgIHRoaXMucXVlcnlTZWxlY3RvcignLnNlbGVjdGlvbi12YWx1ZScpLnRleHRDb250ZW50ID0gJyc7CiAgICAgICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuc291cmNlLWJ0biwgLmNvbnRyb2wtYnRuJykuZm9yRWFjaChidG4gPT4gYnRuLmNsYXNzTGlzdC5yZW1vdmUoJ3NlbGVjdGVkJykpOwogICAgICAgICAgICAgICAgdXBkYXRlVGFrZUJ1dHRvbigpOwogICAgICAgICAgICB9KTsKCiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzZWxlY3RlZC1kZXN0aW5hdGlvbicpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgICBzZWxlY3RlZERlc3RpbmF0aW9uID0gbnVsbDsKICAgICAgICAgICAgICAgIHRoaXMucXVlcnlTZWxlY3RvcignLnNlbGVjdGlvbi12YWx1ZScpLnRleHRDb250ZW50ID0gJyc7CiAgICAgICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZGVzdGluYXRpb24tYnRuJykuZm9yRWFjaChidG4gPT4gYnRuLmNsYXNzTGlzdC5yZW1vdmUoJ3NlbGVjdGVkJykpOwogICAgICAgICAgICAgICAgdXBkYXRlVGFrZUJ1dHRvbigpOwogICAgICAgICAgICAgICAgbG9ja01lc3NhZ2UgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbG9jay1tZXNzYWdlJykuY2xhc3NMaXN0LnJlbW92ZSgndmlzaWJsZScpOwogICAgICAgICAgICB9KTsKCiAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy50YWtlLWJ1dHRvbicpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWRTb3VyY2UgJiYgc2VsZWN0ZWREZXN0aW5hdGlvbikgewogICAgICAgICAgICAgICAgICAgIGZldGNoKCcvcm91dGUnLCB7CiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLAogICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLAogICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHNlbGVjdGVkU291cmNlLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzdGluYXRpb246IHNlbGVjdGVkRGVzdGluYXRpb24KICAgICAgICAgICAgICAgICAgICAgICAgfSkKICAgICAgICAgICAgICAgICAgICB9KQogICAgICAgICAgICAgICAgICAgIC50aGVuKHJlc3BvbnNlID0+IHJlc3BvbnNlLmpzb24oKSkKICAgICAgICAgICAgICAgICAgICAudGhlbihkYXRhID0+IHsKICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1JvdXRlIHJlc3BvbnNlOicsIGRhdGEpOwogICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2NrTWVzc2FnZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsb2NrLW1lc3NhZ2UnKTsKICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0xvY2sgbWVzc2FnZSBlbGVtZW50OicsIGxvY2tNZXNzYWdlKTsKICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmxvY2tlZCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1Nob3dpbmcgbG9jayBtZXNzYWdlJyk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NrTWVzc2FnZS5jbGFzc0xpc3QuYWRkKCd2aXNpYmxlJyk7CiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnSGlkaW5nIGxvY2sgbWVzc2FnZScpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9ja01lc3NhZ2UuY2xhc3NMaXN0LnJlbW92ZSgndmlzaWJsZScpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5zdWNjZXNzKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzZXRTZWxlY3Rpb25zKCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB9KQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9KTsKCiAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5jb250cm9sLWJ0bicpLmZvckVhY2goYnRuID0+IHsKICAgICAgICAgICAgICAgIGJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgICAgICAgIHNlbGVjdFNvdXJjZSh0aGlzLmRhdGFzZXQuc291cmNlLCB0aGlzKTsKICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICB9KTsKCiAgICAgICAgICAgIC8vIEluaXRpYWxpemUgYWxsIGNvbXBvbmVudHMKICAgICAgICAgICAgLy8gSW5mbyBidXR0b24gZnVuY3Rpb25hbGl0eQogICAgICAgICAgICBjb25zdCBpbmZvQnV0dG9uID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmluZm8tYnV0dG9uJyk7CiAgICAgICAgICAgIGNvbnN0IGluZm9Nb2RhbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpbmZvLW1vZGFsJyk7CiAgICAgICAgICAgIGNvbnN0IGNsb3NlQnV0dG9uID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLm1vZGFsLWNsb3NlJyk7CiAgICAgICAgICAgIAogICAgICAgICAgICBpbmZvQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgICBpbmZvTW9kYWwuY2xhc3NMaXN0LmFkZCgndmlzaWJsZScpOwogICAgICAgICAgICB9KTsKICAgICAgICAgICAgCiAgICAgICAgICAgIGNsb3NlQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgICBpbmZvTW9kYWwuY2xhc3NMaXN0LnJlbW92ZSgndmlzaWJsZScpOwogICAgICAgICAgICB9KTsKICAgICAgICAgICAgCiAgICAgICAgICAgIC8vIENsb3NlIG1vZGFsIHdoZW4gY2xpY2tpbmcgb3V0c2lkZSBvZiBpdAogICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihldmVudCkgewogICAgICAgICAgICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gaW5mb01vZGFsKSB7CiAgICAgICAgICAgICAgICAgICAgaW5mb01vZGFsLmNsYXNzTGlzdC5yZW1vdmUoJ3Zpc2libGUnKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIAogICAgICAgICAgICB1cGRhdGVUaW1lc3RhbXAoKTsKICAgICAgICAgICAgc2V0dXBTZWFyY2goJ3NvdXJjZS1zZWFyY2gnLCAnc291cmNlLWJ0bicsICdzb3VyY2UtY291bnQnKTsKICAgICAgICAgICAgc2V0dXBTZWFyY2goJ2Rlc3RpbmF0aW9uLXNlYXJjaCcsICdkZXN0aW5hdGlvbi1idG4nLCAnZGVzdGluYXRpb24tY291bnQnKTsKICAgICAgICAgICAgaW5pdGlhbGl6ZUNhdGVnb3JpZXMoKTsKICAgICAgICB9KTsKICAgIDwvc2NyaXB0Pgo8L2JvZHk+CjwvaHRtbD4="""

def load_ui_template():
    global HTML_TEMPLATE
    HTML_TEMPLATE = base64.b64decode(HTML_TEMPLATE_B64).decode('utf-8')

# Global variables
router = None
simulation_mode = False
SOURCES = {
    
}
DESTINATIONS = {

}
SOURCE_ALIASES = {

}
DESTINATION_ALIASES = {

}


#
# Source and Destination Categories
#

SOURCE_CATEGORIES = {
    'SRC CAT 1': ['', '', '', ''], 
    'SRC CAT 2': ['', '', '', ''],
    'SRC CAT 3': ['', '', '', ''],
    'SRC CAT 4': ['', '', '', ''],
    }

DESTINATION_CATEGORIES = {
    'DST CAT 1': ['', '', '', ''], 
    'DST CAT 2': ['', '', '', ''],
    'DST CAT 3': ['', '', '', ''],
    'DST CAT 4': ['', '', '', ''],
}

def categorize_with_mapping(items, category_map):
    #Categorize items based on custom mapping
    categories = {}
    uncategorized = []

    for category, category_items in category_map.items():
        categories[category] = []
        for item in items:
            if item in category_items:
                categories[category].append(item)
        categories[category].sort()

    categorized_items = [item for sublist in category_map.values() for item in sublist]
    uncategorized = [item for item in items if item not in categorized_items]

    if uncategorized:
        categories['Other'] = sorted(uncategorized)

    categories = {k: v for k, v in categories.items() if v}

    return dict(sorted(categories.items()))

def load_router_config():
    global SOURCES, DESTINATIONS, router
    try:
        # Ensure router connection is available
        if router is None:
            initialize_router()
        
        if router is None or simulation_mode:
            logger.warning("Router not available, using empty configuration")
            return {}, {}
        
        # Query sources from router using proper Harris LRC protocol
        sources = []
        SOURCES.clear()
        try:
            router.clear_buffer()
            src_command = "~SRC?Q${NAME}\\\n"
            router.sock.sendall(src_command.encode())
            
            import time
            time.sleep(0.5)
            
            # Read the full response until we see the termination marker
            src_response = ""
            while True:
                chunk = router.sock.recv(4096).decode()
                src_response += chunk
                if '~SRC%Q${NAME}\\' in src_response:  # Complete response received
                    break
                    
            logger.info(f"Source query response length: {len(src_response)} characters")
            logger.info(f"Source query response (first 200 chars): '{src_response[:200]}...'")
            
            # Parse source entries using the working pattern
            src_pattern = r'~SRC%I#\{(\d+)\};NAME\$\{([^}]+)\}'
            src_matches = re.findall(src_pattern, src_response)
            logger.info(f"Source regex matches: {len(src_matches)} total matches")
            
            # Sort by source number and populate SOURCES dict
            src_matches.sort(key=lambda x: int(x[0]))
            for number, name in src_matches:
                SOURCES[int(number)] = name
                sources.append(name)
            
            logger.info(f"Loaded {len(sources)} sources from router")
            
        except Exception as e:
            logger.error(f"Error querying sources: {str(e)}")
        
        # Query destinations from router using proper Harris LRC protocol
        destinations = []
        DESTINATIONS.clear()
        try:
            router.clear_buffer()
            dest_command = "~DEST?Q${NAME}\\\n"
            router.sock.sendall(dest_command.encode())
            
            time.sleep(0.5)
            
            # Read the full response until we see the termination marker
            dest_response = ""
            while True:
                chunk = router.sock.recv(4096).decode()
                dest_response += chunk
                if '~DEST%Q${NAME}\\' in dest_response:  # Complete response received
                    break
                    
            logger.info(f"Destination query response length: {len(dest_response)} characters")
            logger.info(f"Destination query response (first 200 chars): '{dest_response[:200]}...'")
            
            # Parse destination entries using the working pattern
            dest_pattern = r'~DEST%I#\{(\d+)\};NAME\$\{([^}]+)\}'
            dest_matches = re.findall(dest_pattern, dest_response)
            logger.info(f"Destination regex matches: {len(dest_matches)} total matches")
            
            # Sort by destination number and populate DESTINATIONS dict
            dest_matches.sort(key=lambda x: int(x[0]))
            for number, name in dest_matches:
                DESTINATIONS[int(number)] = name
                destinations.append(name)
            
            logger.info(f"Loaded {len(destinations)} destinations from router")
            
        except Exception as e:
            logger.error(f"Error querying destinations: {str(e)}")
        
        # Add alias sources while keeping originals
        for alias in SOURCE_ALIASES.keys():
            if SOURCE_ALIASES[alias] in sources:
                sources.append(alias)

        # Add alias destinations while keeping originals
        for alias in DESTINATION_ALIASES.keys():
            if DESTINATION_ALIASES[alias] in destinations:
                destinations.append(alias)
        
        grouped_sources = categorize_with_mapping(sources, SOURCE_CATEGORIES)
        grouped_destinations = categorize_with_mapping(destinations, DESTINATION_CATEGORIES)
        
        logger.info(f"Successfully loaded and categorized router configuration from router queries")
        return grouped_sources, grouped_destinations
        
    except Exception as e:
        logger.error(f"Error loading router config: {str(e)}")
        return {}, {}
    

def try_router_connection(host, port=52116):
    #Attempt to connect to the router
    global router, simulation_mode
    try:
        router = IP3Router(host, port)
        simulation_mode = False
        logger.info("Successfully connected to physical router")
        return True
    except Exception as e:
        logger.warning(f"Router connection failed: {str(e)}")
        return False

def initialize_router():
    #Initialize router connection
    global router, router_host, router_port
    if router is None and router_host is not None:
        try_router_connection(router_host, router_port)


class RouterHTTPRequestHandler(BaseHTTPRequestHandler):
    #HTTP requets for router control interface
    
    def do_GET(self):
        #Handle GET requests
        parsed_path = urlparse(self.path)
        path = parsed_path.path
        
        if path == '/':
            self.serve_index()
        elif path.startswith('/status/'):
            destination = path.split('/')[-1]
            self.handle_status(destination)
        elif path == '/router_status':
            self.handle_router_status()
        else:
            self.send_error(404, "Not Found")
    
    def do_POST(self):
        #Handle POST requests
        parsed_path = urlparse(self.path)
        path = parsed_path.path
        
        if path == '/route':
            self.handle_route()
        elif path.startswith('/lock/'):
            destination = path.split('/')[-1]
            self.handle_lock(destination)
        elif path.startswith('/unlock/'):
            destination = path.split('/')[-1]
            self.handle_unlock(destination)
        else:
            self.send_error(404, "Not Found")
    
    def serve_index(self):
        #Serve the main index.html page with router data
        try:
            # Load router configuration
            grouped_sources, grouped_destinations = load_router_config()
            
            # Extract flat lists from categorized data
            sources = []
            for category_items in grouped_sources.values():
                sources.extend(category_items)
            sources = sorted(list(set(sources)))  # Remove duplicates and sort
            
            destinations = []
            for category_items in grouped_destinations.values():
                destinations.extend(category_items)
            destinations = sorted(list(set(destinations)))  # Remove duplicates and sort
            
            # Render embedded template with context
            html_content = self.render_template(
                sources=sources,
                destinations=destinations,
                source_categories=list(SOURCE_CATEGORIES.keys()),
                destination_categories=list(DESTINATION_CATEGORIES.keys()),
                source_to_categories={src: [cat for cat, items in SOURCE_CATEGORIES.items() if src in items] for src in sources},
                destination_to_categories={dst: [cat for cat, items in DESTINATION_CATEGORIES.items() if dst in items] for dst in destinations},
                simulation_mode=simulation_mode
            )
            
            self.send_response(200)
            self.send_header('Content-type', 'text/html')
            self.end_headers()
            self.wfile.write(html_content.encode('utf-8'))
            
        except Exception as e:
            logger.error(f"Error serving index: {str(e)}")
            self.send_error(500, f"Internal Server Error: {str(e)}")
    

    
    def handle_route(self):
        #Handle routing requests
        if router is None:
            initialize_router()
        
        try:
            content_length = int(self.headers['Content-Length'])
            post_data = self.rfile.read(content_length)
            data = json.loads(post_data.decode('utf-8'))
            
            source = data.get('source')
            destination = data.get('destination')
            
            if not source or not destination:
                response = {
                    'success': False, 
                    'message': 'Source and destination required'
                }
            else:
                router_destination = DESTINATION_ALIASES.get(destination, destination)
                router_source = SOURCE_ALIASES.get(source, source)
                
                result = router.route(router_source, router_destination)
                
                if result == "locked":
                    response = {
                        'success': False,
                        'locked': True,
                        'message': 'Destination is locked, contact Engineering',
                        'simulation': simulation_mode
                    }
                else:
                    response = {
                        'success': True,
                        'result': result,
                        'simulation': simulation_mode
                    }
            
            self.send_json_response(response)
            
        except Exception as e:
            logger.error(f"Error in route operation: {str(e)}")
            response = {
                'success': False,
                'message': f'Error: {str(e)}',
                'simulation': simulation_mode
            }
            self.send_json_response(response)
    
    def handle_status(self, destination):
        #Handle status requests
        if router is None:
            initialize_router()
        
        try:
            router_destination = DESTINATION_ALIASES.get(destination, destination)
            current_source = router.status(router_destination)
            
            response = {
                'success': True if current_source else False,
                'source': current_source,
                'destination': destination,
                'simulation': simulation_mode
            }
            self.send_json_response(response)
            
        except Exception as e:
            logger.error(f"Error in status check: {str(e)}")
            response = {
                'success': False,
                'message': str(e),
                'simulation': simulation_mode
            }
            self.send_json_response(response)
    
    def handle_router_status(self):
        #Handle router status requests
        if router is None:
            initialize_router()
        
        response = {
            'simulation_mode': simulation_mode,
            'status': 'Simulated' if simulation_mode else 'Connected'
        }
        self.send_json_response(response)
    
    def handle_lock(self, destination):
        #Handle lock destination requests
        if router is None:
            initialize_router()
        
        try:
            router_destination = DESTINATION_ALIASES.get(destination, destination)
            success = router.lock_destination(router_destination)
            response = {
                'success': success,
                'message': f"{'Successfully locked' if success else 'Failed to lock'} {destination}",
                'simulation': simulation_mode
            }
            self.send_json_response(response)
            
        except Exception as e:
            logger.error(f"Error in lock operation: {str(e)}")
            response = {
                'success': False,
                'message': f'Error: {str(e)}',
                'simulation': simulation_mode
            }
            self.send_json_response(response)
    
    def handle_unlock(self, destination):
        #Handle unlock destination requests
        if router is None:
            initialize_router()
        
        try:
            router_destination = DESTINATION_ALIASES.get(destination, destination)
            success = router.unlock_destination(router_destination)
            response = {
                'success': success,
                'message': f"{'Successfully unlocked' if success else 'Failed to unlock'} {destination}",
                'simulation': simulation_mode
            }
            self.send_json_response(response)
            
        except Exception as e:
            logger.error(f"Error in unlock operation: {str(e)}")
            response = {
                'success': False,
                'message': f'Error: {str(e)}',
                'simulation': simulation_mode
            }
            self.send_json_response(response)
    
    def send_json_response(self, data):
        #Send a JSON response
        json_data = json.dumps(data)
        self.send_response(200)
        self.send_header('Content-type', 'application/json')
        self.end_headers()
        self.wfile.write(json_data.encode('utf-8'))
    
    def render_template(self, **context):
        #Render the embedded HTML template with context data
        rendered = HTML_TEMPLATE
        
        # Generate HTML for sources
        sources_html = ""
        for source in context.get('sources', []):
            categories = " ".join(context.get('source_to_categories', {}).get(source, []))
            sources_html += f'<div class="source-btn" data-source="{source}" data-categories="{categories}">{source}</div>\n'
        
        # Generate HTML for destinations  
        destinations_html = ""
        for destination in context.get('destinations', []):
            categories = " ".join(context.get('destination_to_categories', {}).get(destination, []))
            destinations_html += f'<div class="destination-btn" data-destination="{destination}" data-categories="{categories}">{destination}</div>\n'
        
        # Generate HTML for source categories
        source_categories_html = ""
        for category in context.get('source_categories', []):
            source_categories_html += f'<button class="category-btn" data-category="{category}">{category}</button>\n'
        
        # Generate HTML for destination categories
        destination_categories_html = ""
        for category in context.get('destination_categories', []):
            destination_categories_html += f'<button class="category-btn" data-category="{category}">{category}</button>\n'
        
        # Router status
        router_status = "active" if not context.get('simulation_mode', False) else ""
        
        # Simulation banner
        simulation_banner = '<div class="simulation-banner">Router Not Connected</div>' if context.get('simulation_mode', False) else ""
        
        # Current timestamp
        timestamp = datetime.now().strftime('%d/%m/%Y %H:%M:%S')
        
        # Replace placeholders
        rendered = rendered.replace('{sources}', sources_html)
        rendered = rendered.replace('{destinations}', destinations_html)
        rendered = rendered.replace('{source_categories}', source_categories_html)
        rendered = rendered.replace('{destination_categories}', destination_categories_html)
        rendered = rendered.replace('{router_status}', router_status)
        rendered = rendered.replace('{simulation_banner}', simulation_banner)
        rendered = rendered.replace('{timestamp}', timestamp)
        
        return rendered
    
    def log_message(self, format, *args):
        logger.info(f"{self.address_string()} - {format % args}")


def start_server(port=5050):
    server_address = ('0.0.0.0', port)
    httpd = HTTPServer(server_address, RouterHTTPRequestHandler)
    logger.info(f"Starting HTTP server on {server_address[0]}:{server_address[1]}")
    
    # Initialize router in a separate thread
    router_thread = threading.Thread(target=initialize_router)
    router_thread.daemon = True
    router_thread.start()
    
    try:
        httpd.serve_forever()
    except KeyboardInterrupt:
        logger.info("Server stopped by user")
        httpd.shutdown()


def parse_arguments():
    parser = argparse.ArgumentParser(description='Harris LRC Router Control Server')
    parser.add_argument('--host', required=True, help='Router IP address (required)')
    parser.add_argument('--port', type=int, default=52116, help='Router port (default: 52116)')
    return parser.parse_args()

def set_router_config(host, port):
    global router_host, router_port
    router_host = host
    router_port = port

if __name__ == '__main__':
    args = parse_arguments()
    set_router_config(args.host, args.port)
    
    logger.info(f"Starting router control server...")
    logger.info(f"Router: {router_host}:{router_port}")
    logger.info(f"Web server will run on port 5050")
    
    load_ui_template()  
    start_server(5050)
